package flat/compiler

import flat/io
import flat/ast
import flat/compiler/models
import flat/lexer
import flat/parser
import flat/parser/flat/FileParser as FlatFileParser
import flat/parser/java/FileParser as JavaFileParser
import flat/writer/es6/Es6Writer
import flat/writer/flat/FlatWriter
import flat/log/Logger
import flat/time/Time
import flat/time/Timer
import flat/eventstream
import flat/fucli
import flat/regex

import flat/regex/RegexStringExtensions
import flat/writer/WriterPatternExtensions

class {
  static Logger log = Logger(Compiler.class)

  static CliArg excludeArg = CliArg("--exclude", ["-x"], count: 1)
  static CliArg threadsArg = CliArg("--threads", ["-t"], count: 1)
  static CliArg languageArg = CliArg("--language", ["--lang"], count: 1)
  static CliArg targetArg = CliArg("--target", ["-t"], count: 1)
  static CliArg syncArg = CliArg("--sync")
  static CliArg dryArg = CliArg("--dry")

  static var Long totalLineCount = 0
  static var Long totalBytes = 0
  static var Bool loggedProgress = false

  public static async main(String[] args) {
    let fucli = FuCli([
      excludeArg,
      threadsArg,
      languageArg,
      targetArg,
      syncArg,
      dryArg,
    ]):parse(args.skip(2))

    let completeTimer = Timer():start()

    let inputFile = File(args[1])

    let excludes = excludeArg.values.map({ Pattern(_) })
    let extension = languageArg.value ?: "flat"

    if (inputFile.isDirectory) {
      let files = inputFile.getChildFiles(true)
        .filter({ _.extensionName == extension })
        .filterAsync(file => excludes.noneAsync(x => file.getCanonicalPath().matches(x)))

      let failures = if (syncArg.enabled) {
        files.filterAsync({ !compileFile(_) })
      } else {
        files.filterParallel({ !compileFile(_) }, maxParallel: threadsArg.enabled ? Int.parseInt(threadsArg.value) : 10)
      }

      if (failures.count > 0) {
        log.info("Compiled #{files.count - failures.count}/#{files.count} file#{files.count == 1 ? "" : "s"} with #{failures.count} failure#{failures.count == 1 ? "" : "s"}")
        System.exit(1)
      } else {
        log.info("Successfully compiled #{files.count} file#{files.count == 1 ? "" : "s"}, #{totalLineCount} line#{totalLineCount == 1 ? "" : "s"}, #{totalBytes} byte#{totalBytes == 1 ? "" : "s"}")
      }
    } else {
      compileFile(inputFile)
    }

    completeTimer.stop()

    log.info("Done! Took #{completeTimer.duration}ms")
  }

  static async compileFile(File sourceFile) -> Bool {
    var successful = true

    let tokenizerTimer = Timer()
    let lexTimer = Timer()
    let parseTimer = Timer()
    let fileTimer = Timer()
    let writeTimer = Timer()
    let completeTimer = Timer()

    let streams = EventStream[]

    log.info("Compiling file #{sourceFile.nativeLocation}...")

    completeTimer.start()

    fileTimer.start()
    let fileStream = streams.add(sourceFile.createReadStream())
    fileStream.on("close", { fileTimer.stop() })

    if (syncArg.enabled) fileStream.waitFor("close")

    let bytes = sourceFile.bytes
    totalBytes += bytes
    var Int bytesParsed = 0

    if (syncArg.enabled) {
      startTime = Time.currentTimeMillis
      processedSteps = 0
      lastProgress = 0
      stepsToProcess = bytes
    } else {
      stepsToProcess += bytes
    }

    tokenizerTimer.start()
    var Int tokenCount = 0
    let lexemeStream = streams.add(Tokenizer().tokenize(fileStream))
    lexemeStream.on<Lexeme>("data", lexeme => log.debugFunc({"Lexeme: '#{lexeme.value}'"}))
    lexemeStream.on<Lexeme>("data", { tokenCount++ })
    lexemeStream.on("close", { tokenizerTimer.stop() })
    lexemeStream.emit("start")

    if (syncArg.enabled) lexemeStream.waitFor("close")

    lexTimer.start()
    let tokenStream = streams.add(Lexer().lexemesToTokens(lexemeStream))
    tokenStream.on<Token>("data", token => log.debugFunc({"Token: '#{token.value}'"}))
    tokenStream.on<Token>("data", token => {
      if (token.type == Token.Type.WHITESPACE) {
        totalLineCount += token.value.howMany('\n')
      }
    })
    tokenStream.on("close", { lexTimer.stop() })
    tokenStream.emit("start")

    if (syncArg.enabled) tokenStream.waitFor("close")

    let rootParser = match languageArg.value {
      "java" => JavaFileParser()
      default => FlatFileParser()
    }

    parseTimer.start()
    let nodeStream = streams.add(Parser().parse(rootParser, ParseContext(file: sourceFile), tokenStream))
    nodeStream.on("quit", {
      successful = false
      log.info("Closing streams for file #{sourceFile.nativeLocation}")
      streams.forEach((stream) => {
        stream.emit("close")
        stream.close()
      })
      processedSteps += bytes - bytesParsed
      startTime = Time.currentTimeMillis
    })
    nodeStream.on<NodeResult>("data", result => log.debugFunc({"Node: #{result.node}"}))
    nodeStream.on<Token>("parsed_token", token => {
      processedSteps += token.value.count
      bytesParsed += token.value.count
      logProgress()
    })
    nodeStream.on("close", { parseTimer.stop() })
    nodeStream.emit("start")

    if (syncArg.enabled) nodeStream.waitFor("close")

    if (!dryArg.enabled) {
      let writer = match targetArg.value {
        "es6" => Es6Writer()
        default => FlatWriter()
      }
      let rootWriter = match targetArg.value {
        "es6" => FlatFileParser().pattern.getWriter()
        default => FlatFileParser().pattern.getWriter()
      }

      writeTimer.start()
      let writeStream = streams.add(writer.write(nodeStream, rootWriter))
      writeStream.on("close", { writeTimer.stop() })
      writeStream.emit("start")

      if (syncArg.enabled) writeStream.waitFor("close")
    }

    if (!syncArg.enabled) {
      streams.forEachAsync({ _.waitFor("close") })
    }

    completeTimer.stop()

    loggedProgress = false

    log.info("Finished compiling file #{sourceFile.nativeLocation}! Took #{completeTimer.duration}ms (reading file: #{fileTimer.duration}ms, tokenizing #{tokenizerTimer.duration}ms, lexing #{lexTimer.duration}ms, parsing #{parseTimer.duration}ms, writing #{writeTimer.duration}ms (#{tokenCount} tokens))")

    return successful
  }

  public static etaTime(String defaultText = "...") -> String {
		if (lastProgress <= 1) {
			return defaultText
		}

		let currentTime = Time.currentTimeMillis
		let elapsedMs = currentTime - startTime

		let remainingMs = Math.round(elapsedMs * (100.0 / lastProgress)) - elapsedMs

		return (remainingMs / 1000) + "s"
	}

  static var Int processedSteps = 0
  static var Int stepsToProcess = 0
  static var Int lastProgress = 0
  static var Long startTime = Time.currentTimeMillis

  static logProgress() {
    let prefix = loggedProgress ? "\x1B[1A\x1B[K" : ""

    Console.log(prefix + getProgressLog())

    loggedProgress = true
  }

  static getProgressLog() -> String {
    if (stepsToProcess == 0) {
			return ""
		}

		lastProgress = Math.max(lastProgress, (processedSteps * 100) / stepsToProcess)

		let etaValue = etaTime()

		let prefix = "["
		let percentage = ((processedSteps * 100) / stepsToProcess) + "%"
		let suffix = "] " +
			" ".repeat(Math.max(0, stepsToProcess.toString().count - processedSteps.toString().count)) +
			processedSteps + "/" + stepsToProcess + " " +
			"eta " + " ".repeat(Math.max(0, 3 - etaValue.count)) + etaValue
		let progressLength = 80 - prefix.count - suffix.count

		var percentagePosition = 0
		var printedTip = false
		var progress = ""

		for (i in 0..progressLength) {
			let progressPosition = (lastProgress * progressLength) / 100

			if (percentagePosition < percentage.count && i >= (progressLength / 2) - (percentage.count / 2)) {
				progress += percentage[percentagePosition]
				percentagePosition++
				if (i >= progressPosition) {
					printedTip = true
				}
			} else if (i < progressPosition) {
				progress += "="
			} else if (!printedTip) {
				progress += ">"
				printedTip = true
			} else {
				progress += " "
			}
		}

    if (processedSteps == stepsToProcess) {
      processedSteps = 0
      stepsToProcess = 0
      lastProgress = 0
      startTime = Time.currentTimeMillis
    }

		return prefix + progress + suffix
  }
}
